/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Speech-Synthesizer.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Speech Synthesizer
 #	author : miyako
 #	2025/03/24
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Speech-Synthesizer.h"

#pragma mark -

namespace speech
{
    typedef struct
    {
#if VERSIONMAC
        NSString *text;
        NSURL *url;
        NSString *voice;
#endif
        float rate;
        float volume;
    }say_ctx;

}

#if VERSIONMAC
#pragma mark NSSpeechSynthesizerDelegate

@interface SpeechSynthesizerDelegate : NSObject <NSSpeechSynthesizerDelegate>
{
    uint32_t indx;
    NSSpeechSynthesizer *speechSynthesizer;
}

- (id)initWithVoice:(NSString *)voice volume:(float)volume rate:(float)rate url:(NSURL *)url text:(NSString *)text;

- (void)speechSynthesizer:(NSSpeechSynthesizer *)sender didFinishSpeaking:(BOOL)success;

- (void)abort;

- (BOOL)isSpeaking;

@end

#pragma mark ctx ref

namespace speech
{
    //flag to prevent creating instances after OnExit
    BOOL isDying = NO;
    
    std::map<uint32_t, SpeechSynthesizerDelegate*> speech_contexts;
    
    uint32_t speech_context_add(SpeechSynthesizerDelegate *speech)
    {
        uint32_t i = 1;
        
        while (speech_contexts.find(i) != speech_contexts.end()) i++;
        
        speech_contexts.insert(std::map<uint32_t, SpeechSynthesizerDelegate*>::value_type(i, speech));
        
        //    NSLog(@"add%i", i);
        
        return i;
    }
    
    void speech_context_remove(uint32_t i)
    {
        std::map<uint32_t, SpeechSynthesizerDelegate*>::iterator pos = speech_contexts.find(i);
        
        if(pos != speech_contexts.end())
        {
            speech_contexts.erase(pos);
            
            //        NSLog(@"remove%i", i);
        }
    }
    
}

@implementation SpeechSynthesizerDelegate

- (id)initWithVoice:(NSString *)voice volume:(float)volume rate:(float)rate url:(NSURL *)url text:(NSString *)text
{
    self = [super init];
    
    if (self)
    {
        speechSynthesizer = [[NSSpeechSynthesizer alloc]initWithVoice:voice];
        
        if(speechSynthesizer)
        {
            indx = speech::speech_context_add(self);
            
            [speechSynthesizer setVolume:volume];
            [speechSynthesizer setRate:rate];
            [speechSynthesizer setDelegate:self];
            
            if(url)
            {
                [speechSynthesizer startSpeakingString:text toURL:url];
                [url release];
            }else
            {
                [speechSynthesizer startSpeakingString:text];
            }
            [text release];
        }
    }
    
    return self;
}

- (void)abort
{
    if(speechSynthesizer)
    {
        [speechSynthesizer setDelegate:nil];
        [speechSynthesizer release];
        speechSynthesizer = nil;
    }
    
    [self release];
}

- (void)dealloc
{
        [super dealloc];
}

- (void)speechSynthesizer:(NSSpeechSynthesizer *)sender didFinishSpeaking:(BOOL)success
{
    speech::speech_context_remove(indx);
    
    [self abort];
}

- (BOOL)isSpeaking
{
    if(!speechSynthesizer) return NO;
    
    return [speechSynthesizer isSpeaking];
}

@end

namespace speech
{
    void say(say_ctx *ctx)
    {
        if(!speech::isDying)
        {
            
            NSString *voice = nil;
            
            if(ctx->voice)
            {
                NSArray *voices = [NSSpeechSynthesizer availableVoices];
                NSUInteger i = [voices indexOfObjectPassingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop)
                                {
                    if ([(NSString *)obj isEqualToString:ctx->voice])
                    {
                        return YES;
                    }
                    return NO;
                }];
                
                if(NSNotFound != i)
                {
                    voice = [voices objectAtIndex:i];
                }
                [ctx->voice release];
            }
            
            [[SpeechSynthesizerDelegate alloc]initWithVoice:voice
                                                     volume:ctx->volume
                                                       rate:ctx->rate
                                                        url:ctx->url
                                                       text:ctx->text];
        
        }
    }
}
#endif

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
#if VERSIONMAC
        case kCloseProcess :
//            onCloseProcess();
            break;
#endif
			// --- Speech Synthesizer
            
			case 1 :
				VOICES_LIST(params);
				break;
			case 2 :
				SAY(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void VOICES_LIST(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    ARRAY_TEXT Param1;

#if VERSIONWIN
    
    HRESULT hr = S_OK;
    ISpVoice *pVoice = NULL;
    ISpObjectToken *pToken = NULL;
    IEnumSpObjectTokens *pEnum = NULL;
    
    if (CoInitialize(NULL))
    {
        hr = CoCreateInstance(CLSID_SpVoice, NULL, CLSCTX_ALL, IID_ISpVoice, (void **)&pVoice);
        if (SUCCEEDED(hr))
        {
            hr = SpEnumTokens(SPCAT_VOICES, NULL, NULL, &pEnum);
            if (SUCCEEDED(hr))
            {
                ULONG ulCount = 0;
                hr = pEnum->GetCount(&ulCount);
                if (SUCCEEDED(hr) && ulCount)
                {
                    Param1.setSize(1);
                    unsigned int i = 0;
                    while (SUCCEEDED(hr) && i < ulCount)
                    {
                        hr = pEnum->Next(1, &pToken, NULL);
                        i++;
                        if (SUCCEEDED(hr))
                        {
                            wchar_t *voiceName = NULL;
                            hr = SpGetDescription(pToken, &voiceName);
                            if (SUCCEEDED(hr))
                            {
                                Param1.appendUTF16String((PA_Unichar *)voiceName, wcslen((const wchar_t *)voiceName));
                            }//SpGetDescription
                            pToken->Release();
                            pToken = NULL;
                        }//Next
                    }//while
                }//GetCount
                
                pEnum->Release();
                pEnum = NULL;
                
            }//SpEnumTokens
            
            hr = SpEnumTokens(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech_OneCore\\Voices", NULL, NULL, &pEnum); //Cortana voice
            if (SUCCEEDED(hr))
            {
                ULONG ulCount = 0;
                hr = pEnum->GetCount(&ulCount);
                if (SUCCEEDED(hr) && ulCount)
                {
                    if (Param1.getSize() == 0)
                        Param1.setSize(1);
                    
                    unsigned int i = 0;
                    while (SUCCEEDED(hr) && i < ulCount)
                    {
                        hr = pEnum->Next(1, &pToken, NULL);
                        i++;
                        if (SUCCEEDED(hr))
                        {
                            wchar_t *voiceName = NULL;
                            hr = SpGetDescription(pToken, &voiceName);
                            if (SUCCEEDED(hr))
                            {
                                Param1.appendUTF16String((PA_Unichar *)voiceName, wcslen((const wchar_t *)voiceName));
                            }//SpGetDescription
                            pToken->Release();
                            pToken = NULL;
                        }//Next
                    }//while
                }//GetCount
                
                pEnum->Release();
                pEnum = NULL;
                
            }//SpEnumTokens
            
            pVoice->Release();
            pVoice = NULL;
        }//CoCreateInstance
        CoUninitialize();
    }//CoCreateInstance
#else
    NSArray *voices = [NSSpeechSynthesizer availableVoices];
    
    if([voices count])
    {
        Param1.setSize(1);
        for(NSUInteger i = 0; i < [voices count];++i)
            Param1.appendUTF16String((NSString *)[voices objectAtIndex:i]);
    }
#endif
    
    Param1.toParamAtIndex(pParams, 1);
}

void SAY(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param3;

    Param1.fromParamAtIndex(pParams, 1);
    Param3.fromParamAtIndex(pParams, 3);

#if VERSIONMAC
    //need to call API in main thread
    speech::say_ctx ctx;
    ctx.text = Param1.copyUTF16String();
    ctx.url    = Param3.copyUrl();
    ctx.rate = 180.0f;
    ctx.volume = 0.0f;
    ctx.voice = nil;
#else
    long rate;
    unsigned short volume;
    CUTF16String voiceId;
#endif
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 2);
    if(options) {
        if(ob_is_defined(options, L"rate")) {
#if VERSIONMAC
            ctx.rate = ob_get_n(options, L"rate");
#else
            rate = ob_get_n(options, L"rate");
#endif
        }
        if(ob_is_defined(options, L"volume")) {
#if VERSIONMAC
            ctx.volume = ob_get_n(options, L"volume");
#else
            volume = ob_get_n(options, L"volume");
#endif
        }
        if(ob_is_defined(options, L"voice")) {
            CUTF8String u8;
            ob_get_s(options, L"voice", &u8);
#if VERSIONMAC
            ctx.voice = [[NSString alloc]initWithUTF8String:(const char *)u8.c_str()];
#else
            GetVoiceId((char *)u8.c_str(), voiceId);
#endif
        }
        
    }
    
#if VERSIONWIN
    
    HRESULT hr = S_OK;
    ISpVoice * pVoice = NULL;
    ISpStream * pStream = NULL;
    ISpStreamFormat * pStreamFormat = NULL;

    if(CoInitialize(NULL))
    {
        hr = CoCreateInstance(CLSID_SpVoice, NULL, CLSCTX_ALL, IID_ISpVoice, (void **)&pVoice);
        if(SUCCEEDED(hr))
        {
            hr = pVoice->SetVoice(NULL); //default voice
            hr = pVoice->SetVolume(volume); //0 to 100
            hr = pVoice->SetRate(rate); //-10 to 10
            
            //use specified voice
            if(voiceId.length())
            {
                ISpObjectToken *pToken = NULL;
                hr = SpGetTokenFromId((const WCHAR *)voiceId.c_str(), &pToken);
                if(SUCCEEDED(hr))
                {
                    hr = pVoice->SetVoice(pToken);
                    pToken->Release();
                    pToken = NULL;
                }
            }

            hr = CoCreateInstance(CLSID_SpStream, NULL, CLSCTX_ALL, IID_ISpStream, (void **)&pStream);
            if(SUCCEEDED(hr))
            {
                HANDLE h = pVoice->SpeakCompleteEvent();

                if(Param3.getUTF16Length())
                {

                    WAVEFORMATEX format;
                    const GUID guid = SPDFID_WaveFormatEx;
                    
                    //SPSF_16kHz16BitMono;
                    format.cbSize = 0;
                    format.nAvgBytesPerSec = 44100;
                    format.nBlockAlign = 2;
                    format.nChannels = 1;
                    format.nSamplesPerSec = 22050;
                    format.wBitsPerSample = 16;
                    format.wFormatTag =WAVE_FORMAT_PCM;
                    
                    hr = pStream->BindToFile((LPCWSTR)Param3.getUTF16StringPtr(),
                                                                     SPFM_CREATE_ALWAYS,
                                                                     &guid,
                                                                     &format,
                                                                     SPFEI_ALL_EVENTS);
                    
                    hr = pVoice->SetOutput(pStream, FALSE);
                    hr = pVoice->Speak((LPCWSTR)Param1.getUTF16StringPtr(), SPF_ASYNC|SPF_PURGEBEFORESPEAK|SPF_DEFAULT, NULL);
                }else
                {
                    hr = pVoice->Speak((LPCWSTR)Param1.getUTF16StringPtr(), SPF_ASYNC|SPF_DEFAULT, NULL);
                }
                
                //be nice to 4D; better than WaitUntilDone()
                if (SUCCEEDED(hr))
                {
                    do
                    {
                        PA_YieldAbsolute();

                    } while (WAIT_TIMEOUT == WaitForSingleObject(h, 10));

                }
            
                pStream->Release();
                pStream = NULL;
            }//CoCreateInstance
            pVoice->Release();
            pVoice = NULL;
        }//CoCreateInstance
        CoUninitialize();
    }//CoInitialize
    
#else
    PA_RunInMainProcess((PA_RunInMainProcessProcPtr)speech::say, &ctx);
#endif
}

#if VERSIONWIN
static BOOL GetVoiceId(char *voiceNameStr, CUTF16String &voiceId)
{
    BOOL found = FALSE;
    
    if(voiceNameStr)
    {
        CUTF16String voiceName;
        C_TEXT t;
        t.setUTF8String((const uint8_t *)voiceNameStr, strlen(voiceNameStr));
        t.copyUTF16String(&voiceName);
        
        HRESULT hr = S_OK;
        IEnumSpObjectTokens *pEnum = NULL;
        ISpObjectToken *pToken = NULL;

        if(voiceName.length())
        {
            hr = SpEnumTokens(SPCAT_VOICES, NULL, NULL, &pEnum);
            if (SUCCEEDED(hr))
            {
                ULONG ulCount = 0;
                hr = pEnum->GetCount(&ulCount);
                if (SUCCEEDED(hr) && ulCount)
                {
                    unsigned int i = 0;
                    while (SUCCEEDED(hr) && i < ulCount)
                    {
                        hr = pEnum->Next(1, &pToken, NULL);
                        i++;
                        if (SUCCEEDED(hr))
                        {
                            wchar_t *_voiceName = NULL;
                            hr = SpGetDescription(pToken, &_voiceName);
                            if (SUCCEEDED(hr))
                            {
                                if(!_wcsicmp(_voiceName, (const wchar_t *)voiceName.c_str()))
                                {
                                    wchar_t *_voiceId = NULL;
                                    hr = pToken->GetId(&_voiceId);
                                    if (SUCCEEDED(hr))
                                    {
                                        voiceId = CUTF16String((const PA_Unichar *)_voiceId, wcslen(_voiceId));
                                        hr = E_ABORT;
                                        found = TRUE;
                                    }
                                }
                            }//SpGetDescription
                            pToken->Release();
                            pToken = NULL;
                        }//Next
                    }//while
                }//GetCount
                pEnum->Release();
                pEnum = NULL;
            }//SpEnumTokens
        }
        if(!found)
        {
            hr = SpEnumTokens(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech_OneCore\\Voices", NULL, NULL, &pEnum); //Cortana voice
            if (SUCCEEDED(hr))
            {
                ULONG ulCount = 0;
                hr = pEnum->GetCount(&ulCount);
                if (SUCCEEDED(hr) && ulCount)
                {
                    unsigned int i = 0;
                    while (SUCCEEDED(hr) && i < ulCount)
                    {
                        hr = pEnum->Next(1, &pToken, NULL);
                        i++;
                        if (SUCCEEDED(hr))
                        {
                            wchar_t *_voiceName = NULL;
                            hr = SpGetDescription(pToken, &_voiceName);
                            if (SUCCEEDED(hr))
                            {
                                if(!_wcsicmp(_voiceName, (const wchar_t *)voiceName.c_str()))
                                {
                                    wchar_t *_voiceId = NULL;
                                    hr = pToken->GetId(&_voiceId);
                                    if (SUCCEEDED(hr))
                                    {
                                        voiceId = CUTF16String((const PA_Unichar *)_voiceId, wcslen(_voiceId));
                                        hr = E_ABORT;
                                        found = TRUE;
                                    }
                                }
                            }//SpGetDescription
                            pToken->Release();
                            pToken = NULL;
                        }//Next
                    }//while
                }//GetCount
                pEnum->Release();
                pEnum = NULL;
            }//SpEnumTokens
        }
    }
    return found;
}
#endif

#if VERSIONMAC
static bool isProcessOnExit()
{
    PA_long32 state, time;
    std::vector<PA_Unichar>name(256);
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), &name[0], &state, &time);
    CUTF16String procName(&name[0]);
    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
    return (!procName.compare(exitProcName));
}
static void onExit()
{
    for(std::map<uint32_t, SpeechSynthesizerDelegate*>::iterator i = speech::speech_contexts.begin(); i != speech::speech_contexts.end(); i++)
    {
        SpeechSynthesizerDelegate *speech = i->second;
        [speech abort];
    }
    
    speech::speech_contexts.clear();
}
static void onCloseProcess()
{
    if(isProcessOnExit())
    {
        speech::isDying = YES;
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)onExit, NULL);
    }
}
#endif
